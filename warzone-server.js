
//====================================================
// External libraries
//====================================================
const express = require('express');
const path = require('path');
const { connect } = require('http2');
const app = express();
var http = require('http').createServer(app);
const player_io = require('socket.io')(http);
const managerapp = express();
var http2 = require('http').createServer(managerapp);
const manager_io = require('socket.io')(http2);
const fs = require('fs');
const crypto = require('crypto');

//====================================================
// Variables
//====================================================

// Game object. New game entries are generated by newGame()
var game = {};

// playerID / socketID map
// playerID
// |- socketID
var playerSocketID = {};

// socketID / playerID map
// socketID (key)
// |- playerID
var socketPlayerID = {};

// playerID / gameID map
// playerID
// - gameID
var playerGameID = {};

// managerID / socketID map
// managerID (key)
// |- socketID
var managerSocketID = {};

// socketID / managerID map
// socketID (key)
// |- managerID
var socketManagerID = {};

// Prevents the auto-save routine to save on start-up
var skipStartupSave = true;

//====================================================
// Object creation
//====================================================

// Creates a new game data structure in the game object, and returns the unique game id.
function newGame(gamePassword) {
    // Generate a unique random game ID
    var gameID = Math.round(Math.random() * 999999);
    while (gamePassword[gameID] != undefined) {
        gameID = Math.round(Math.random() * 999999);
    }

    // Add new game structure to game object
    game[gameID] = newGameData(gamePassword);

    generateWeaponCostArray(gameID);

    return gameID;
}

// Returns a default game data structure
function newGameData(gamePassword) {
    return {
        password        : gamePassword,             // Manager password hash
        settings        : {                         // === Game settings ===
            title                   : 'New Game',   // 
            exRate                  : 0.6,          // Exchange rate from local currency to NOK
            newWeaponPerMinute      : 10,           // Weapons generated per minute if arsenal is not full.
            weaponCostMin           : 10,           // Lowest weapon cost
            weaponCostMax           : 1000,         // Highest weapon cost
            weaponCostCentre        : 100,          // Centre weapon cost
            weaponCostMinPriority   : 1,            // priority at min cost
            weaponCostMaxPriority   : 1,            // priority at max cost
            weaponCostCentrePriority: 5,            // priority at centre cost
            playerDefaultCredit     : 0,            // Default credit allocated to each new player
            visorMinDiameter        : 30,           // minimum visor diameter
            visorMaxDiameter        : 100,          // maximum visor diameter
            victoryOpacity          : 0.2,          // Opacity of victory circles
        },
        player          : {},                       // === Players object ===
        total           : {                         // === Game totals ===
            totalZar       : 0,                     // Total of weapon purchases in ZAR
            totalNok       : 0,                     // Total of weapon purchases in NOK
            totalCreditZar : 0,                     // Total credit spent in ZAR
            totalCreditNok : 0,                     // Total credit spent in NOK
        },
        victory         : [],                       // === Victories array ===
        weaponData      : [],                       // === Array with imported weapon data ===
        weapon          : {},                       // === Object with generated (active) weapons ===
        weaponSold      : {},                       // === Object with sold weapons ===
        weaponIDcounter : 0,                        // Counter to keep track of latest weapon ID
        weaponCostArray : [],                       // Weighted weapon cost array generated from weapon cost settings
    };
}

// Creates a new player data object, and returns the player ID
function newPlayer(gameID, name, phoneNumber, creditZar) {
    var playerID = newPlayerID(gameID, name, phoneNumber)

    var p = parseFloat(creditZar);
    var c = game[gameID].settings.playerDefaultCredit + p;

    game[gameID].player[playerID] = {
        name        : name,
        phoneNumber : phoneNumber,
        creditZar   : c,
        creditNok   : convertZarNok(gameID, c),
        totalZar    : 0,
        totalNok    : 0,
    };

    return playerID;
}

// generate player id from gameID, name and phone number
function newPlayerID(gameID, name, phoneNumber) {
    return (gameID.toString().replace(/ +/g, "") + name.replace(/ +/g, "") + phoneNumber.replace(/ +/g, "")).toLowerCase(); // remove whitespace from id
}

//====================================================
// Startup logic
//====================================================

// Set socket.io server timeout values. Change from default
// 60s / 5s ping to 20s / 1s ping to allow faster client 
// disconnection detection to avoid players getting an error
// that their login is already used.
player_io.eio.pingTimeout = 20000;
player_io.eio.pingInterval = 1000;

// load the game from disk
loadGame();

// Start weapon spawn timers
Object.keys(game).forEach((gameID) => {
    spawnWeapon(gameID)
});

// start timer to save data every minute to disk for data recovery after a server crash
saveTimeout();

//====================================================
// Player Web & socket.io server
//====================================================

// HTTP & socket.io server
try {
    http.listen(8081, () => {
        eventLog('debug', 'Server listening on *:8081');
    });
}
catch (err) {
    eventLog('error', 'socket.io error: ' + err.message);
}


// Serve local settings web UI HTTP
app.get('/', (req, res) => {
    res.sendFile(__dirname + '/client/warzone-client.html');
});

app.get('/warzone-client.css', (req, res) => {
    res.sendFile(__dirname + '/client/warzone-client.css');
});

app.get('/warzone-client.js', (req, res) => {
    res.sendFile(__dirname + '/client/warzone-client.js');
});

app.get('/manifest.json', (req, res) => {
    res.sendFile(__dirname + '/client/manifest.json');
});

// Serve image files
app.use("/img", express.static(path.join(__dirname, "/client/img")));

// Serve javascript files
app.use("/js", express.static(path.join(__dirname, "/client/js")));

//====================================================
// Manager Web & socket.io server
//====================================================

// HTTP & socket.io server
http2.listen(8082, () => {
    try {
        eventLog('debug', 'Server listening on *:8082');
    }
    catch (err) {
        eventLog('error', `Express Web server error: ${err}`);
    }
});

// Serve local settings web UI HTTP
managerapp.get('/', (req, res) => {
    try {
        res.sendFile(__dirname + '/manager/warzone-manager.html');
    }
    catch (err) {
        eventLog('error', `Express Web server error: ${err}`);
    }
});

managerapp.get('/warzone-manager.css', (req, res) => {
    try {
        res.sendFile(__dirname + '/manager/warzone-manager.css');
    }
    catch (err) {
        eventLog('error', `Express Web server error: ${err}`);
    }
});

managerapp.get('/warzone-manager.js', (req, res) => {
    try {
        res.sendFile(__dirname + '/manager/warzone-manager.js');
    }
    catch (err) {
        eventLog('error', `Express Web server error: ${err}`);
    }
});

// Serve javascript files
managerapp.use("/js", express.static(path.join(__dirname, "/manager/js")));


//====================================================
// manager socket.io connection
//====================================================

manager_io.on('connection', (socket) => {
    eventLog('manager','Manager connected');

    // promt manager to (re)authenticate. Only used by the manager if already authenticated, and the connection was interrupted.
    socket.emit('auth');

    // Manager auth. ID should only be read on authentication to prevent hacking of the id. ID's are tracked via Socket ID
    socket.on('reqAuth', (gameID, password) => { 
        try {
            // check if new game
            if (gameID == undefined || gameID == "") {
                // check if password is relatively secure. (can add proper password complexity checking here if needed.)
                if (password.length < 8) {
                    // Fail authentication with "too short" message
                    socket.emit('authFail', 'Please enter a password of at least 8 characters');
                }
                else {
                    // create new game
                    var newID = newGame(passwordHash(password));

                    // Add id <-> socket mappings
                    managerSocketID[newID] = socket.id;
                    socketManagerID[socket.id] = newID;

                    // Pass authentication with game ID
                    socket.emit('authSuccess', newID);

                    // Emit game settings for manager ID
                    socket.emit('settings', game[newID].settings);

                    // Emit game totals
                    socket.emit('gameData', game[newID].total);

                    // Add manager socket to game ID "room". This enables us to update all manager instances logged in with the same name/id
                    socket.join(`${newID}`);

                    // Start weapon spawning timer
                    spawnWeapon(newID);
                }
            }

            // authenticate existing manager
            else {
                // check if ID exists and password is correct (if not existing, gamePassword[id] will return "undefined", and auth will fail)
                if (game[gameID] != undefined && game[gameID].password == passwordHash(password)) {
                    // Add id / socket mappings
                    managerSocketID[gameID] = socket.id;
                    socketManagerID[socket.id] = gameID;

                    // send auto success to manager with id
                    socket.emit('authSuccess', gameID);

                    // Emit game settings for manager ID
                    socket.emit('settings', game[gameID].settings);

                    // Emit game totals
                    socket.emit('gameData', game[gameID].total);

                    // Add manager socket to game ID "room". This enables us to update all manager instances logged in with the same name/id
                    socket.join(`${gameID}`);
                }
                else {
                    // Fail authentication
                    socket.emit('authFail', 'Invalid Game ID or password');
                }
            }
        }
        catch (err) {
            eventLog('error', 'Unable to authenticate manager: ' + err.message);
        }
    });

    // receive updated settings from manager
    socket.on('settings', (data) => {
        // Find game ID from stored manager / socket ID map
        var gameID = socketManagerID[socket.id];

        eventLog('manager', `Updated settings received from manager for Game ID ${gameID}`);

        // parse data received from manager
        var d = objectParseFloat(data);

        // determine if weapon spawn process should be started after settings update
        var runSpawnWeapon = game[gameID].settings.newWeaponPerMinute == 0 && d.newWeaponPerMinute > 0;
        
        // Update game settings
        Object.keys(d).forEach((key) => {
            game[gameID].settings[key] = d[key];
        })

        // Start spawn weapon timer if stopped
        if (runSpawnWeapon) {
            spawnWeapon(gameID);
        }

        // Update managers with updated settings
        manager_io.in(`${gameID}`).emit('settings', game[gameID].settings);

        // Update players game title
        player_io.in(`${gameID}`).emit('gameTitle', game[gameID].settings.title);

        // Re-generate weapons cost array
        generateWeaponCostArray(gameID);
    });

    // receive list of players with credits from manager
    socket.on('players', (data) => {
        // Find game ID from stored game / socket ID map
        var gameID = socketManagerID[socket.id];

        eventLog('manager', `Loading players list for Game ID ${gameID}...`);

        for (let i = 0; i < data.length; i++){
            newPlayer(gameID, data[i].name, data[i].phoneNumber, data[i].creditZar);
        }

        eventLog('manager', `Players list loaded for Game ID ${gameID}`);
    });

    // receive list of weapons from manager
    socket.on('weapons', (data) => {
        // Find game ID from stored game / socket ID map
        var gameID = socketManagerID[socket.id];

        eventLog('manager', `Loading weapons list for Game ID ${gameID}...`);
        game[gameID].weaponData = data;
        
        // remove existing weapons
        Object.keys(game[gameID].weapon).forEach((weaponID) => {
            // broadcast weapon remove
            player_io.in(`${gameID}`).emit('removeWeapon', weaponID);

            // Remove weapon from weapons list
            delete game[gameID].weapon[weaponID];
        });
        
        eventLog('manager', `Weapons list loaded for Game ID ${gameID}`);
    });

    // reset game
    socket.on('reset', () => {
        // Find game ID from stored game / socket ID map
        var gameID = socketManagerID[socket.id];

        eventLog('manager', `Game reset command received from manager for Game ID ${gameID}`);

        // remove existing weapons
        Object.keys(game[gameID].weapon).forEach((weaponID) => {
            // broadcast weapon remove
            player_io.in(`${gameID}`).emit('removeWeapon', weaponID);
        });
        
        // emit authFail to all players.
        player_io.in(`${gameID}`).emit('authFail', "The game has been reset by your game administrator.");

        // clear player socket mappings
        Object.keys(game[gameID].player).forEach((playerID) => {
            var socketID = playerSocketID[playerID];

            if (socketID != undefined) { delete socketPlayerID[socketID]; }
            delete playerSocketID[playerID];
        });

        // Delete players
        game[gameID].player = {};

        // Reset game totals
        game[gameID].total.totalZar = 0;
        game[gameID].total.totalNok = 0;
        game[gameID].total.totalCreditZar = 0;
        game[gameID].total.totalCreditNok = 0;

        // Clear victories
        game[gameID].victory.length = 0;
        
        // Clear weapons
        game[gameID].weaponSold = {};
        game[gameID].weapon = {};
        game[gameID].weaponIDcounter = 0;
        game[gameID].weaponData.length = 0;
    });
});

// broadcast event log to manager UI(s), and log to console
function eventLog(eventClass, message) {
    var msg = new Date().toUTCString() + '    ' + eventClass + '    ' + message;
    // manager_io.emit('eventLog', msg); ########## to do
    console.log(msg);
}

//====================================================
// player socket.io connection
//====================================================

player_io.on('connection', (socket) => {
    // promt player to (re)authenticate. Only used by the player if already authenticated, and the connection was interrupted.
    socket.emit('auth');

    socket.on('disconnect', () => {
        playerID = socketPlayerID[socket.id];
        gameID = playerGameID[playerID];

        if (playerID != undefined) {
            // Remove playerID socketID and gameID mappings
            if (socketPlayerID != undefined) { delete socketPlayerID[socket.id]; }
            if (playerSocketID != undefined) { delete playerSocketID[playerID]; }
            delete playerGameID[playerID];

            eventLog('debug', `Player disconnected: ${playerID} (socket.id ${socket.id})`);
        }
    });

    // Client auth. Only accept first request, and deny subsequent requests if first connection is active
    socket.on('reqAuth', (playerData) => { // playerID = game ID + name + phoneNumber
        // check if id exists in playerSocketID
        playerID = newPlayerID(playerData.gameID, playerData.name, playerData.phoneNumber);

        // Check if Game ID exists
        if (game[playerData.gameID] == undefined) {
            // Fail authentication
            socket.emit('authFail', 'Oops, this did not work... You either entered an invalid game ID, or you might be logged in already using the same details.');
            eventLog('debug', `Player auth fail (invalid Game ID): ${playerID} (socket.id ${socket.id})`);
        }

        // New / reconnected player
        else if (playerSocketID[playerID] == undefined) {
            // create playerID socketID mappings
            playerSocketID[playerID] = socket.id;
            socketPlayerID[socket.id] = playerID;
            playerGameID[playerID] = playerData.gameID; // player ID / game ID mapping

            // Create new player if not existing already
            if (game[playerData.gameID].player[playerID] == undefined){
                newPlayer(playerData.gameID, playerData.name, playerData.phoneNumber, 0);
            }
            
            // new player. Allow access
            socket.emit('authSuccess', playerID);

            // add new player to game room
            socket.join(`${playerData.gameID}`)

            eventLog('debug', `Player auth success: ${playerID} (socket.id ${socket.id})`);

            // Send initial data
            socket.emit('weapon', game[playerData.gameID].weapon);
            socket.emit('gameData', game[playerData.gameID].total);
            socket.emit('gameTitle', game[playerData.gameID].settings.title);
            socket.emit('playerData', game[playerData.gameID].player[playerID]);
        }
        else {
            // player already active. Deny access
            socket.emit('authFail', 'Oops, this did not work... You either entered an invalid game ID, or you might be logged in already using the same details.');
            eventLog('debug', `Player auth fail (player already logged in): ${playerID} (socket.id ${socket.id})`);
        }
    });

    // player weapons request (send all weapons to player)
    socket.on('reqWeapons', () => {
        var playerID = socketPlayerID[socket.id];
        var gameID = playerGameID[playerID];

        socket.emit('weapon', game[gameID].weapon);
    });

    // player buy weapon request
    socket.on('buyWeapon', (weaponID) => {
        var playerID = socketPlayerID[socket.id];
        var gameID = playerGameID[playerID];

        if (playerID != undefined && 
            game[gameID] != undefined) {    //&& game[gameID].weapon[weaponID] != undefined
            buyWeapon(gameID, playerID, weaponID);

            // send visor to player
            socket.emit('visor', visor(gameID, weaponID));

            // broadcast weapon remove
            player_io.in(`${gameID}`).emit('removeWeapon', weaponID);

            // broadcast total to players and managers
            player_io.in(`${gameID}`).emit('gameData', game[gameID].total);
            manager_io.in(`${gameID}`).emit('gameData', game[gameID].total);

            // emit player stats
            socket.emit('playerData', game[gameID].player[playerID]);
        }
    });

    // player request to shoot
    socket.on('reqShoot', (shot) => {
        var playerID = socketPlayerID[socket.id];
        var gameID = playerGameID[playerID];

        var v = calcVictory(gameID, shot.x, shot.y, shot.weaponID, playerID);

        // check for valid victory
        if (v != false) {
            // broadcast the victory to all users
            player_io.in(`${gameID}`).emit('victory', [v]);
        }
        else {
            // send visor to player to try to shoot again
            if (game[gameID].weaponSold[shot.weaponID] != undefined) {
                socket.emit('visor', visor(gameID, shot.weaponID));
            }
        }
    });

    // player request list of victories. Player sends current victory count.
    // server sends all newer victories than count
    socket.on('reqVictory', (count) => {
        var playerID = socketPlayerID[socket.id];
        var gameID = playerGameID[playerID];

        if (game[gameID].victory.length > count) {
            socket.emit('victory', game[gameID].victory.slice(count, game[gameID].victory.length));
        }
    });
});

// Broadcast weapon to all players
function broadcastWeapon(gameID, weaponID) {
    var w = {
        [weaponID] : game[gameID].weapon[weaponID]
    };

    player_io.in(`${gameID}`).emit('weapon', w);
}

//====================================================
// weapon functions
//====================================================

// Create new weapon in Weapon object
function newWeapon(gameID, name, cost, seller, text) {
       
    var weaponID = game[gameID].weaponIDcounter;
    game[gameID].weapon[weaponID] = {
        name      : name,
        cost      : cost,
        seller    : seller,
        text      : text,
    };

    game[gameID].weaponIDcounter++;
    return weaponID;
}

// player weapon purchase
function buyWeapon(gameID, playerID, weaponID) {
        
    var w;
    if (game[gameID].weapon[weaponID] != undefined) {
        w = game[gameID].weapon[weaponID];
        
        // move weapon to sold
        game[gameID].weaponSold[weaponID] = w;
        delete game[gameID].weapon[weaponID];

        // set buyer name
        game[gameID].weaponSold[weaponID].buyer = game[gameID].player[playerID].name;

        eventLog('debug', `Weapon ${weaponID} sold to player ${playerID} for ${w.cost}`);
    }
    else {
        w = game[gameID].weaponSold[weaponID];

        // duplicate the sold weapon (happens when more than one player is buying a weapon simultaneously. The sale is duplicated in this case for the new player)
        c = game[gameID].weaponIDcounter;
        if (c != undefined) {
            game[gameID].weaponIDcounter++;
            game[gameID].weaponSold[c] = JSON.parse(JSON.stringify(w));

            // set buyer name
            game[gameID].weaponSold[weaponID].buyer = game[gameID].player[playerID].name;    
        
            eventLog('debug', `Weapon ${weaponID} sold to player ${playerID} as duplicate weapon ${c} for ${w.cost}`);
        }
    }

    // player credit & total
    var credit = game[gameID].player[playerID].creditZar - w.cost;

    if (credit <= 0) {  // credit depleted
        game[gameID].player[playerID].creditZar = 0;
        game[gameID].player[playerID].totalZar += -1*credit;

        // Add difference in cost and (negative) credit to total credit spent.
        game[gameID].total.totalCreditZar += w.cost + credit;
    }
    else {
        game[gameID].player[playerID].creditZar = credit;

        // Add full weapon cost to credit, as credit is not depleted yet
        game[gameID].total.totalCreditZar += w.cost;
    }

    // currency conversion
    game[gameID].player[playerID].creditNok = convertZarNok(gameID, game[gameID].player[playerID].creditZar);
    game[gameID].player[playerID].totalNok = convertZarNok(gameID, game[gameID].player[playerID].totalZar);

    // game totals
    game[gameID].total.totalZar += w.cost;
    game[gameID].total.totalNok = convertZarNok(gameID, game[gameID].total.totalZar);
    game[gameID].total.totalCreditNok = convertZarNok(gameID, game[gameID].total.totalCreditZar);
}

// Weapon generation logic
function spawnWeapon(gameID) {

    if (Object.keys(game[gameID].weapon).length < 5 && game[gameID].settings.newWeaponPerMinute > 0) // player can only display a max of 5 weapons
    {
        // Select weapon from list
        if (game[gameID].weaponData.length > 0) {
            // Random index
            var i = Math.round(Math.random() * (game[gameID].weaponData.length - 1))

            var weaponID = newWeapon(
                gameID,
                game[gameID].weaponData[i].name,
                randomWeaponCost(gameID),
                game[gameID].weaponData[i].seller,
                game[gameID].weaponData[i].text
            );
        }
        else {
            // demo weapon data
            var weaponID = newWeapon(gameID,'','','','');
            game[gameID].weapon[weaponID].name = `name${weaponID}`;
            game[gameID].weapon[weaponID].cost = randomWeaponCost(gameID);
            game[gameID].weapon[weaponID].seller = `seller${weaponID}`;
            game[gameID].weapon[weaponID].text = `text${weaponID} text${weaponID} text${weaponID} text${weaponID} text${weaponID} text${weaponID} text${weaponID} text${weaponID} text${weaponID} text${weaponID} text${weaponID} text${weaponID} text${weaponID} text${weaponID} text${weaponID} text${weaponID} text${weaponID} text${weaponID} text${weaponID} text${weaponID} text${weaponID} text${weaponID} text${weaponID} text${weaponID} text${weaponID} text${weaponID} text${weaponID} text${weaponID} text${weaponID} text${weaponID} text${weaponID} text${weaponID} text${weaponID} text${weaponID} text${weaponID} text${weaponID} text${weaponID} text${weaponID} text${weaponID} text${weaponID} text${weaponID} text${weaponID} text${weaponID} text${weaponID} text${weaponID} text${weaponID} `;
        }        

        // broadcast new weapon to all players
        broadcastWeapon(gameID, weaponID);
    }

    // call this routine after delay
    if (game[gameID].settings.newWeaponPerMinute > 0) {
        setTimeout(function() { spawnWeapon(gameID) }, 60000 / game[gameID].settings.newWeaponPerMinute);
    }
}

// Weapon cost array generator
function generateWeaponCostArray(gameID) {
    // Generate array of numbers from lowest cost to highest cost
    var l = [];
    for (let i = game[gameID].settings.weaponCostMin; i <= game[gameID].settings.weaponCostMax; i++) {
        l.push(i);        
    }

    // create / clear the weapon cost array
    game[gameID].weaponCostArray.length = 0;
    
    // centre cost at min or max cost. ignore centre cost and weight
    if (game[gameID].settings.weaponCostMin == game[gameID].settings.weaponCostCentre 
    || game[gameID].settings.weaponCostMax == game[gameID].settings.weaponCostCentre) {
        for (let j = 0; j < l.length; j++)
        {
            // x1 = weaponCostMin
            // x2 = weaponCostMax
            // y1 = weaponCostMinPriority
            // y2 = weaponCostMaxPriority
            // x = current cost
            // y = priority at current cost
            var p = linearGraphPoint(
                game[gameID].settings.weaponCostMin,
                game[gameID].settings.weaponCostMax,
                game[gameID].settings.weaponCostMinPriority,
                game[gameID].settings.weaponCostMaxPriority,
                l[j] // current cost
            );

            // round current cost
            var digits = `${l[j]}`.length;
            var rounded = round(l[j],-1*(digits - 1));

            // generate number of items in weaponCostArray according to priority (multiplier)
            for (let k = 0; k < p; k++) {
                game[gameID].weaponCostArray.push(rounded);
            }
        }
    }

    // centre cost between min and max cost
    else if (game[gameID].settings.weaponCostMin < game[gameID].settings.weaponCostCentre 
    && game[gameID].settings.weaponCostMax > game[gameID].settings.weaponCostCentre) {
        for (let j = 0; j < l.length; j++)
        {
            // linear graph from min cost to centre cost
            if (l[j] <= game[gameID].settings.weaponCostCentre) {
                // x1 = weaponCostMin
                // x2 = weaponCostCentre
                // y1 = weaponCostMinPriority
                // y2 = weaponCostCentrePriority
                // x = current cost
                // y = priority at current cost
                var p = linearGraphPoint(
                    game[gameID].settings.weaponCostMin,
                    game[gameID].settings.weaponCostCentre,
                    game[gameID].settings.weaponCostMinPriority,
                    game[gameID].settings.weaponCostCentrePriority,
                    l[j] // current cost
                );
    
                // round current cost
                var digits = `${l[j]}`.length;
                var rounded = round(l[j],-1*(digits - 1));
    
                // generate number of items in weaponCostArray according to priority (multiplier)
                for (let k = 0; k < p; k++) {
                    game[gameID].weaponCostArray.push(rounded);
                }
            }
            // linear graph from centre cost to max cost
            else {
                // x1 = weaponCostCentre
                // x2 = weaponCostMax
                // y1 = weaponCostCentrePriority
                // y2 = weaponCostMaxPriority
                // x = current cost
                // y = priority at current cost
                var p = linearGraphPoint(
                    game[gameID].settings.weaponCostCentre,
                    game[gameID].settings.weaponCostMax,
                    game[gameID].settings.weaponCostCentrePriority,
                    game[gameID].settings.weaponCostMaxPriority,
                    l[j] // current cost
                );
    
                // round current cost
                var digits = `${l[j]}`.length;
                var rounded = round(l[j],-1*(digits - 1));
    
                // generate number of items in weaponCostArray according to priority (multiplier)
                for (let k = 0; k < p; k++) {
                    game[gameID].weaponCostArray.push(rounded);
                }
            }
        }
    }
}

// Returns a random weapon cost from the weighted weaponCostArray
function randomWeaponCost(gameID) {
    if (game[gameID].weaponCostArray.length > 0) {
        var i = Math.round(Math.random() * (game[gameID].weaponCostArray.length - 1));
        return game[gameID].weaponCostArray[i];
    }
    else {
        return 0;
    }
}

//====================================================
// visor functions
//====================================================

// calculate visor settings from weapon
function visor(gameID, weaponID) {
    return {
        diameter : visorSize(gameID, weaponID),
        weaponID : weaponID,
    };
}

// calculate visor size
function visorSize(gameID, weaponID) {
    var d =  linearGraphPoint(
        Math.sqrt(game[gameID].settings.weaponCostMin),
        Math.sqrt(game[gameID].settings.weaponCostMax),
        game[gameID].settings.visorMinDiameter,
        game[gameID].settings.visorMaxDiameter,
        Math.sqrt(game[gameID].weaponSold[weaponID].cost)
    );

    if (d > game[gameID].settings.visorMaxDiameter) {
        return game[gameID].settings.visorMaxDiameter
    }
    else if (d < game[gameID].settings.visorMinDiameter) {
        return game[gameID].settings.visorMinDiameter;
    }
    else {
        return d;
    }
}

//====================================================
// shooting functions
//====================================================

// calculates and adds the victory to the victory list, and return victory details if valid shot.
// returns false if invalid shot
function calcVictory(gameID, x, y, weaponID, playerID) {
    // data validation. Return false (invalid shot) if data not valid
    if (game[gameID].player == undefined || 
        game[gameID].player[playerID] ==  undefined ||
        game[gameID].weaponSold == undefined ||
        game[gameID].weaponSold[weaponID] == undefined) {
            return false;
        }
    
    var v = {
        playerName  : game[gameID].player[playerID].name,
        diameter    : visorSize(gameID, weaponID),
        opacity     : game[gameID].settings.victoryOpacity,
        x           : x,
        y           : y,
    };

    // this version of game does not have victory logic yet, so victory is granted indefinitely.
    // add victory to victory array
    game[gameID].victory.push(v);
    return v;
}

//====================================================
// general functions
//====================================================

// Get point on linear graph
function linearGraphPoint(x1,x2,y1,y2,x)
{
    return (x-x1)*(y2 - y1)/(x2-x1)+y1;
}

// Rounding function with precision
function round(value, precision) {
    // source: https://stackoverflow.com/questions/7342957/how-do-you-round-to-1-decimal-place-in-javascript
    var multiplier = Math.pow(10, precision || 0);
    return Math.round(value * multiplier) / multiplier;
}

// Parse single depth JSON object data. If string, keep string value.
function objectParseFloat(data) {
    var o = {};
    Object.keys(data).forEach((k) => {
        var p = parseFloat(data[k]);
        if (isNaN(p)) {
            o[k] = data[k];
        }
        else {
            o[k] = p;
        }
    });

    return o;
}

// Generate a password hash
function passwordHash(password) {
    const secret = "63z7x4_,6Ce~a+XW";

    return crypto.createHmac('sha256', secret)
                        .update(password)
                        .digest('hex');
}

function convertZarNok(gameID, zar) {
    return Math.round(zar * game[gameID].settings.exRate);
}

// return true if variable is an object
function isObject(variable) {
    return typeof variable === 'object' &&
    !Array.isArray(variable) &&
    variable !== null;
}

// return a copy of an object
function copyObject(object) {
    return JSON.parse(JSON.stringify(object));
}

//====================================================
// file handling
//====================================================

// timer to save data every min
function saveTimeout() {
    if (!skipStartupSave)
    {
        saveGame();
    }
    skipStartupSave = false;
    setTimeout(saveTimeout, 60000);
};

// save game data on gracefull shutdown
process.on('exit', exitServer);
process.on('SIGINT', exitServer);
process.on('SIGTERM', exitServer);

var exitSaved = false;
function exitServer() {
    // save game
    if (!exitSaved) {
        saveGame();
        exitSaved = true;
    }
    
    // exit process
    process.exit();
}

//dump game to file
function saveGame(){
    var data = JSON.stringify(game, null, 2);  //pretty print
    try {
        eventLog('debug', "Saving games to disk...");
        fs.writeFileSync('saveGame.json', data);
    }
    catch (err){
        eventLog('error', 'Unable to write saveGame.json to disk: ' + err.message);
    }
}

//load saveGame from file
function loadGame(){
    try {
        eventLog('debug', "Loading games from disk...");

        // Read clientData.json from file
        var raw = fs.readFileSync('saveGame.json');

        // Parse JSON file
        game = JSON.parse(raw);

        // reference game data structure
        var refGame = newGameData('');

        // Validate loaded game data
        Object.keys(game).forEach(gameID => {
            updateObject(refGame, game[gameID]);
        });
    }
    catch (err) {
        eventLog('error', 'Unable to load saveGame.json from file: ' + err.message);
    }
}

//====================================================
// data validation
//====================================================

// Updates a target object with new key : value pairs from the reference object.
function updateObject(reference, target) {
    if (isObject(reference) && isObject(target)) {
        Object.keys(reference).forEach(key => {
            if (target[key] == undefined) {
                // create missing data
                target[key] = copyObject(reference[key]);
            }
            else {
                // validate child objects
                updateObject(reference[key], target[key]);
            }
        });
    }
}